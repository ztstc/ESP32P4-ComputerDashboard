// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.3
// LVGL version: 9.2.2
// Project name: ComputerDashboard

#include "ui.h"
#include "nvs.h"
#include "nvs_flash.h"
#include "esp_err.h"
#include "bsp/display.h"
#include "esp_wifi_remote.h"
#include "esp_event.h"
#include "freertos/FreeRTOS.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "esp_hosted.h"
// #include "esp_hosted_bt.h"
// #include "esp_hosted_bluedroid.h"
#include "esp_sntp.h"
#include "esp_netif.h"
#include <time.h>
#include <sys/time.h> // 新增：timeval 结构体
#include "tasks.h"
#include "esp_system.h"
#include "esp_mac.h"
#include "lwip/inet.h"
#include "esp_wifi.h"
#include "esp_efuse.h"

// 这些函数在后文使用，先做前向声明
void check_wifi(lv_event_t * e);
static void wifi_scan_done_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data);
static void wifi_conn_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data);
static void start_wifi_scan(void);
static void wifi_scan_retry_timer_cb(lv_timer_t * t);
// 新增：MAC 工具函数前向声明，避免 AboutInfo 调用时报隐式声明
static bool mac_is_zero(const uint8_t mac[6]);
static esp_err_t get_sta_mac(uint8_t mac[6]);
// 新增：天气立即刷新接口（由 tasks.c 提供）
void tasks_request_weather_now(void);

// 需要用到的外部UI对象（不同屏上定义）
extern lv_obj_t * uic_WifSsidLabel;
extern lv_obj_t * uic_WifiStatusLabel;
extern lv_obj_t * uic_time9;     // 新增：时间标签
extern lv_obj_t * uic_time;      // 新增：时间标签
extern lv_obj_t * uic_TimeNow;   // 新增：时间标签
extern lv_obj_t * uic_Year;          // 新增：年份标签
extern lv_obj_t * uic_MonthDay;      // 新增：月日标签
extern lv_obj_t * uic_DayOfWeekLabel;// 新增：星期标签
// 需要的额外 UI 对象
extern lv_obj_t * uic_MACLabel;
extern lv_obj_t * uic_ComputerIParea;
extern lv_obj_t * uic_ComputerIPLabel;
extern lv_obj_t * uic_IPLabel;
extern lv_obj_t * uic_loading;
// 监控指标 UI（tasks.c 已引用，这里保证存在）
extern lv_obj_t * uic_CPULoadLabel;
extern lv_obj_t * uic_CPULoad;
extern lv_obj_t * uic_GPULoadLabel;
extern lv_obj_t * uic_GPULoad;
extern lv_obj_t * uic_RAMLoad;
extern lv_obj_t * uic_RAMLoadLabel;
extern lv_obj_t * uic_Disk1Load;
extern lv_obj_t * uic_Disk2Load;
extern lv_obj_t * uic_Disk3Load;
extern lv_obj_t * uic_Disk1Label;
extern lv_obj_t * uic_Disk2Label;
extern lv_obj_t * uic_Disk3Label;
extern lv_obj_t * uic_UploadLabel;
extern lv_obj_t * uic_DownloadLabel;

// 若未在其它编译单元定义, 提供弱定义以解决链接报错 (undefined reference)
__attribute__((weak)) lv_obj_t * uic_time9 = NULL;
__attribute__((weak)) lv_obj_t * uic_time = NULL;
__attribute__((weak)) lv_obj_t * uic_TimeNow = NULL;
__attribute__((weak)) lv_obj_t * uic_Year = NULL;
__attribute__((weak)) lv_obj_t * uic_MonthDay = NULL;
__attribute__((weak)) lv_obj_t * uic_DayOfWeekLabel = NULL;

// BSP 显示锁原型（由 BSP 提供实现）
bool bsp_display_lock(uint32_t timeout_ms);
void bsp_display_unlock(void);

// 维护WiFi状态
static bool s_wifi_inited = false;
static bool s_wifi_started = false;
static bool s_scan_handler_registered = false;
static esp_event_handler_instance_t s_scan_evt_ins;
static bool s_conn_handler_registered = false;
static esp_event_handler_instance_t s_conn_c_ins;
static esp_event_handler_instance_t s_conn_d_ins;
static bool s_scan_in_progress = false;
static lv_timer_t * s_scan_retry_timer = NULL;
static lv_timer_t * s_time_timer = NULL; // 新增：时间更新定时器 (废弃: 由tasks接管)
static bool s_sntp_started = false;      // 新增：SNTP是否已启动 (废弃: 由tasks接管)
static bool s_ip_handler_registered = false; // 新增：是否已注册IP事件
static esp_event_handler_instance_t s_ip_evt_ins; // 新增：IP事件实例

// ===== 自动亮度：状态/定时器 =====
static lv_timer_t *s_auto_bri_timer = NULL;
static bool s_auto_bri_enabled = false;

static void auto_brightness_apply(void)
{
    // 读取基准亮度
    int32_t base = 50;
    nvs_handle_t nvs_handle;
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_i32(nvs_handle, "brightness", &base);
        nvs_close(nvs_handle);
    }
    if (base < 1) base = 1;
    if (base > 100) base = 100;

    // 当前本地时间
    time_t now = time(NULL);
    struct tm tm_info = {0};
    localtime_r(&now, &tm_info);

    // 计算比例（简单分段 + 过渡）
    int hour = tm_info.tm_hour;
    int min  = tm_info.tm_min;
    float scale = 1.0f;

    if (hour < 6) {
        scale = 0.30f; // 深夜
    } else if (hour < 8) {
        // 06:00(0.60) -> 08:00(1.00) 线性
        int minutes = (hour - 6) * 60 + min; // 0..120
        scale = 0.60f + (minutes / 120.0f) * 0.40f;
    } else if (hour < 20) {
        scale = 1.00f; // 白天
    } else if (hour < 23) {
        // 20:00(1.00) -> 23:00(0.50) 线性
        int minutes = (hour - 20) * 60 + min; // 0..180
        scale = 1.00f - (minutes / 180.0f) * 0.50f;
        if (scale < 0.50f) scale = 0.50f;
    } else {
        scale = 0.30f; // 深夜
    }

    int target = (int)(base * scale + 0.5f);
    if (target < 1) target = 1;
    if (target > 100) target = 100;
    bsp_display_brightness_set(target);
}

static void auto_brightness_timer_cb(lv_timer_t *t)
{
    (void)t;
    auto_brightness_apply();
}

static void auto_brightness_start(void)
{
    if (s_auto_bri_enabled && s_auto_bri_timer) return;
    s_auto_bri_enabled = true;
    if (!s_auto_bri_timer) {
        s_auto_bri_timer = lv_timer_create(auto_brightness_timer_cb, 60000, NULL); // 每分钟
    }
    // 立即应用一次
    auto_brightness_apply();
}

static void auto_brightness_stop(void)
{
    s_auto_bri_enabled = false;
    if (s_auto_bri_timer) {
        lv_timer_del(s_auto_bri_timer);
        s_auto_bri_timer = NULL;
    }
    // 恢复到用户设定基准亮度
    int32_t base = 50;
    nvs_handle_t nvs_handle;
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_i32(nvs_handle, "brightness", &base);
        nvs_close(nvs_handle);
    }
    if (base < 1) base = 1;
    if (base > 100) base = 100;
    bsp_display_brightness_set(base);
}

// 扫描结果传递到LVGL线程的数据结构
typedef struct {
    int unique_cnt;
    char unique[9][33];
    bool has_connected;
    char connected_ssid[33];
} wifi_scan_result_t;

// 提前定义连接状态结构，供 wifi_off 等处使用
typedef struct {
    bool connected;
    char ssid[33];
} wifi_conn_ui_t;

// 在后文实现，先做前向声明
static void ui_apply_conn_status(void *param);

// 辅助：设置密码页SSID并清空密码框（供 WifiConnect1-9 调用）
static void ui_set_pwd_screen_ssid(const char *ssid)
{
    extern lv_obj_t * ui_SSIDlabel;
    extern lv_obj_t * ui_wifipwdarea;
    if (ui_SSIDlabel) lv_label_set_text(ui_SSIDlabel, ssid ? ssid : "");
    if (ui_wifipwdarea) lv_textarea_set_text(ui_wifipwdarea, "");
}

void rotate_image(lv_event_t * e)
{
	// 弃用
}

void load_info(lv_event_t * e)
{
    //弃用
}

void wifi_on(lv_event_t * e)
{
    // 打开wifi并尝试连接nvs内的wifi SSID (改为后台自动任务)
    wifi_mode_t mode;
    if (esp_wifi_get_mode(&mode) == ESP_OK) {
        s_wifi_inited = true;
    }
    if (!s_wifi_inited) {
        wifi_init_config_t wifi_init_cfg = WIFI_INIT_CONFIG_DEFAULT();
        esp_err_t ret = esp_wifi_init(&wifi_init_cfg);
        if (ret != ESP_OK) return;
        ret = esp_wifi_set_mode(WIFI_MODE_STA);
        if (ret != ESP_OK) return;
        s_wifi_inited = true;
    }
    if (!s_wifi_started) {
        if (esp_wifi_start() == ESP_OK) {
            s_wifi_started = true;
        }
    }
    // 注册事件处理
    if (s_wifi_inited && !s_scan_handler_registered) {
        if (esp_event_handler_instance_register(WIFI_EVENT, WIFI_EVENT_SCAN_DONE,
                                                &wifi_scan_done_handler, NULL, &s_scan_evt_ins) == ESP_OK) {
            s_scan_handler_registered = true;
        }
    }
    if (s_wifi_inited && !s_conn_handler_registered) {
        if (esp_event_handler_instance_register(WIFI_EVENT, WIFI_EVENT_STA_CONNECTED,
                                                &wifi_conn_handler, NULL, &s_conn_c_ins) == ESP_OK &&
            esp_event_handler_instance_register(WIFI_EVENT, WIFI_EVENT_STA_DISCONNECTED,
                                                &wifi_conn_handler, NULL, &s_conn_d_ins) == ESP_OK) {
            s_conn_handler_registered = true;
        }
    }
    // 不再注册 IP 事件，这部分由 tasks.c 完成
    // if (s_wifi_inited && !s_ip_handler_registered) {
    //     if (esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP,
    //                                             &ip_event_handler, NULL, &s_ip_evt_ins) == ESP_OK) {
    //         s_ip_handler_registered = true;
    //     }
    // }
    // 保存开关状态
    nvs_handle_t nvs_wifi_handle;
    if (nvs_open("storage", NVS_READWRITE, &nvs_wifi_handle) == ESP_OK) {
        nvs_set_i32(nvs_wifi_handle, "wifi_on", 1);
        nvs_commit(nvs_wifi_handle);
        nvs_close(nvs_wifi_handle);
    }
    // 触发后台自动连接
    tasks_try_auto_connect();
    // 更新WiFi状态显示
    check_wifi(e);
    lv_obj_add_state(uic_WifiButton, LV_STATE_CHECKED);
}

void wifi_off(lv_event_t * e)
{
    // 关闭wifi
    if (s_wifi_started) {
        if (esp_wifi_stop() == ESP_OK) {
            s_wifi_started = false;
        }
    }
	//将wifi开关设置保存到nvs内
	nvs_handle_t nvs_wifi_handle;
	if (nvs_open("storage", NVS_READWRITE, &nvs_wifi_handle) == ESP_OK) {
		nvs_set_i32(nvs_wifi_handle, "wifi_on", 0);
		nvs_commit(nvs_wifi_handle);
		nvs_close(nvs_wifi_handle);
	}
	// 立即更新顶部状态为断开
	wifi_conn_ui_t *info = calloc(1, sizeof(wifi_conn_ui_t));
    if (info) {
        info->connected = false;
        lv_async_call(ui_apply_conn_status, info);
    }
	lv_obj_clear_state(uic_WifiButton, LV_STATE_CHECKED);
    lv_obj_clear_state(uic_wifiSwitch, LV_STATE_CHECKED);
	lv_obj_add_flag(uic_Wifilist, LV_OBJ_FLAG_HIDDEN);
}

void check_wifi(lv_event_t * e)
{
    // 检查 Wi-Fi 状态
    if (s_wifi_started) {
        if (uic_wifiSwitch) lv_obj_add_state(uic_wifiSwitch, LV_STATE_CHECKED);
        wifi_scan(e);
    } else {
        if (uic_wifiSwitch) lv_obj_clear_state(uic_wifiSwitch, LV_STATE_CHECKED);
        if (uic_Wifilist) lv_obj_add_flag(uic_Wifilist, LV_OBJ_FLAG_HIDDEN);
    }
}

// 兼容旧接口：ui_WifiChoose.c 调用的是 wifi_check
void wifi_check(lv_event_t * e)
{
    check_wifi(e);
}

void wifi_scan(lv_event_t * e)
{
    (void)e;
    start_wifi_scan();
}

static void start_wifi_scan(void)
{
    if (!s_wifi_started || s_scan_in_progress) return;
    wifi_scan_config_t scan_cfg = { 0 };
    esp_err_t ret = esp_wifi_scan_start(&scan_cfg, false);
    if (ret == ESP_OK) {
        s_scan_in_progress = true;
    } else {
        // 在连接建立中或状态不允许时延迟重试
        if (s_scan_retry_timer == NULL) {
            s_scan_retry_timer = lv_timer_create(wifi_scan_retry_timer_cb, 700, NULL);
            lv_timer_set_repeat_count(s_scan_retry_timer, 1);
        }
    }
}

static void wifi_scan_retry_timer_cb(lv_timer_t * t)
{
    s_scan_retry_timer = NULL;
    start_wifi_scan();
    lv_timer_del(t);
}

// 在LVGL线程中应用扫描结果，安全更新UI
static void ui_apply_scan_result(void *param)
{
    wifi_scan_result_t *res = (wifi_scan_result_t *)param;
    if (!res) return;
    if (bsp_display_lock(2000)) {
        lv_obj_t *labels[9] = {uic_Wifilistlabel1, ui_Wifilistlabel2, ui_Wifilistlabel3, ui_Wifilistlabel4, ui_Wifilistlabel5, ui_Wifilistlabel6, ui_Wifilistlabel7, ui_Wifilistlabel8, ui_Wifilistlabel9};
        lv_obj_t *btns[9]   = {uic_Wifilist1,      ui_Wifilist2,      ui_Wifilist3,      ui_Wifilist4,      ui_Wifilist5,      ui_Wifilist6,      ui_Wifilist7,      ui_Wifilist8,      ui_Wifilist9};
        for (int i = 0; i < 9; ++i) {
            if (i < res->unique_cnt) {
                if (labels[i]) lv_label_set_text(labels[i], res->unique[i]);
                if (btns[i]) lv_obj_clear_flag(btns[i], LV_OBJ_FLAG_HIDDEN);
            } else {
                if (btns[i]) lv_obj_add_flag(btns[i], LV_OBJ_FLAG_HIDDEN);
            }
        }
        if (res->has_connected) {
            if (uic_Currentwifilabel) lv_label_set_text(uic_Currentwifilabel, res->connected_ssid);
            if (uic_wifistatus) lv_label_set_text(uic_wifistatus, "Connected");
            if (ui_Currentwifi) lv_obj_clear_flag(ui_Currentwifi, LV_OBJ_FLAG_HIDDEN);
            // 同步状态到顶部WiFi状态标签
            if (uic_WifSsidLabel) lv_label_set_text(uic_WifSsidLabel, res->connected_ssid);
            if (uic_WifiStatusLabel) lv_label_set_text(uic_WifiStatusLabel, "connected");
        } else {
            if (ui_Currentwifi) lv_obj_add_flag(ui_Currentwifi, LV_OBJ_FLAG_HIDDEN);
            if (uic_WifSsidLabel) lv_label_set_text(uic_WifSsidLabel, "WLAN");
            if (uic_WifiStatusLabel) lv_label_set_text(uic_WifiStatusLabel, "disconnected");
        }
        lv_obj_clear_flag(uic_Wifilist, LV_OBJ_FLAG_HIDDEN);
        bsp_display_unlock();
    }
    free(res);
}

// 补充缺失的扫描完成回调定义
static void wifi_scan_done_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)
{
    s_scan_in_progress = false;
    uint16_t ap_num = 0;
    esp_wifi_scan_get_ap_num(&ap_num);
    if (ap_num > 50) ap_num = 50;
    wifi_ap_record_t *ap_raw = calloc(ap_num ? ap_num : 1, sizeof(wifi_ap_record_t));
    if (!ap_raw) return;
    esp_wifi_scan_get_ap_records(&ap_num, ap_raw);

    wifi_ap_record_t ap_info = {0};
    bool has_connected = (esp_wifi_sta_get_ap_info(&ap_info) == ESP_OK);

    wifi_scan_result_t *res = calloc(1, sizeof(wifi_scan_result_t));
    if (!res) { free(ap_raw); return; }

    for (int i = 0; i < ap_num && res->unique_cnt < 9; ++i) {
        const char *ssid = (const char *)ap_raw[i].ssid;
        if (!ssid || !ssid[0]) continue;
        if (has_connected && strncmp((const char*)ap_info.ssid, ssid, sizeof(ap_info.ssid)) == 0) continue;
        bool exists = false;
        for (int j = 0; j < res->unique_cnt; ++j) {
            if (strncmp(res->unique[j], ssid, sizeof(res->unique[0])) == 0) { exists = true; break; }
        }
        if (exists) continue;
        snprintf(res->unique[res->unique_cnt], sizeof(res->unique[0]), "%s", ssid);
        res->unique_cnt++;
    }
    res->has_connected = has_connected;
    if (has_connected) snprintf(res->connected_ssid, sizeof(res->connected_ssid), "%s", (const char*)ap_info.ssid);

    free(ap_raw);
    lv_async_call(ui_apply_scan_result, res);
}

static void ui_apply_conn_status(void *param)
{
    wifi_conn_ui_t *info = (wifi_conn_ui_t *)param;
    if (!info) return;
    if (bsp_display_lock(1000)) {
        if (info->connected) {
            if (uic_WifSsidLabel) lv_label_set_text(uic_WifSsidLabel, info->ssid);
            if (uic_WifiStatusLabel) lv_label_set_text(uic_WifiStatusLabel, "connected");
        } else {
            if (uic_WifSsidLabel) lv_label_set_text(uic_WifSsidLabel, "WLAN");
            if (uic_WifiStatusLabel) lv_label_set_text(uic_WifiStatusLabel, "disconnected");
        }
        bsp_display_unlock();
    }
    free(info);
}

static void wifi_conn_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)
{
    // 先分发顶部状态更新到LVGL线程
    wifi_conn_ui_t *info = calloc(1, sizeof(wifi_conn_ui_t));
    if (info) {
        if (event_id == WIFI_EVENT_STA_CONNECTED) {
            const wifi_event_sta_connected_t *ev = (const wifi_event_sta_connected_t *)event_data;
            info->connected = true;
            if (ev) snprintf(info->ssid, sizeof(info->ssid), "%.*s", ev->ssid_len, ev->ssid);
        } else {
            info->connected = false;
        }
        lv_async_call(ui_apply_conn_status, info);
    }
    // 已连接后稍作延迟再尝试扫描，避免与关联流程竞争
    if (event_id == WIFI_EVENT_STA_CONNECTED) {
        if (s_scan_retry_timer == NULL) {
            s_scan_retry_timer = lv_timer_create(wifi_scan_retry_timer_cb, 800, NULL);
            lv_timer_set_repeat_count(s_scan_retry_timer, 1);
        }
    }
}

void LoadInfo(lv_event_t * e)
{
	// 读取NVS中的亮度值
    int32_t brightness = 50; // 默认亮度
    nvs_handle_t nvs_handle;
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_i32(nvs_handle, "brightness", &brightness);
        nvs_close(nvs_handle);
    }
    // 设置亮度滑块的值
    extern lv_obj_t * ui_BrightnessSlider;
    if (ui_BrightnessSlider) {
        lv_slider_set_value(ui_BrightnessSlider, brightness, LV_ANIM_OFF);
    }
	// 读取音量值
	int32_t volume = 50; // 默认音量
	if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
		nvs_get_i32(nvs_handle, "volume", &volume);
		nvs_close(nvs_handle);
	}
	// 设置音量滑块的值
	extern lv_obj_t * ui_VolumeSlider;
	if (ui_VolumeSlider) {
		lv_slider_set_value(ui_VolumeSlider, volume, LV_ANIM_OFF);
	}
	// 读取Wi-Fi状态 如果WiFi已打开 则将uic_wifiSwitch和WifiButton设置为checked 如果未连接到wifi则将uic_WifiSsidLabel内容设置为WLAN uic_WifiStatusLabel设定为disconnected 如果已连接上则将uic_WifiSsidLabel内容设置为当前连接的SSID uic_WifiStatusLabel设定为connected
    int32_t wifi_on = 0;
    char ssid[33] = {0};
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_i32(nvs_handle, "wifi_on", &wifi_on);
        size_t len = sizeof(ssid);
        nvs_get_str(nvs_handle, "wifi_ssid", ssid, &len);
        nvs_close(nvs_handle);
    }
    if (wifi_on) {
        if (uic_wifiSwitch) lv_obj_add_state(uic_wifiSwitch, LV_STATE_CHECKED);
        if (uic_WifiButton) lv_obj_add_state(uic_WifiButton, LV_STATE_CHECKED);
        // 检查当前WiFi连接状态
        wifi_ap_record_t ap_info;
        if (esp_wifi_sta_get_ap_info(&ap_info) == ESP_OK) {
            // 已连接
            if (uic_WifSsidLabel) lv_label_set_text(uic_WifSsidLabel, (const char*)ap_info.ssid);
            if (uic_WifiStatusLabel) lv_label_set_text(uic_WifiStatusLabel, "connected");
        } else {
            // 未连接
            if (uic_WifSsidLabel) lv_label_set_text(uic_WifSsidLabel, "WLAN");
            if (uic_WifiStatusLabel) lv_label_set_text(uic_WifiStatusLabel, "disconnected");
        }
    } else {
        if (uic_wifiSwitch) lv_obj_clear_state(uic_wifiSwitch, LV_STATE_CHECKED);
        if (uic_WifiButton) lv_obj_clear_state(uic_WifiButton, LV_STATE_CHECKED);
        if (uic_WifSsidLabel) lv_label_set_text(uic_WifSsidLabel, "WLAN");
        if (uic_WifiStatusLabel) lv_label_set_text(uic_WifiStatusLabel, "disconnected");
    }

    // 读取自动亮度开关并按需启动
    int32_t auto_on = 0;
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_i32(nvs_handle, "auto_brightness", &auto_on);
        nvs_close(nvs_handle);
    }
    if (auto_on) {
        auto_brightness_start();
    } else {
        auto_brightness_stop();
    }
}

void ChangeBrightness(lv_event_t * e)
{
    // 获取滑块对象和当前值
    lv_obj_t * slider = lv_event_get_target(e);
    int32_t value = lv_slider_get_value(slider);

    // 设置屏幕亮度
    bsp_display_brightness_set(value);

    // 保存亮度到NVS
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err == ESP_OK) {
        nvs_set_i32(nvs_handle, "brightness", value);
        nvs_commit(nvs_handle);
        nvs_close(nvs_handle);
    }

    // 若开启了自动亮度，按新基准立即重算并应用
    if (s_auto_bri_enabled) {
        auto_brightness_apply();
    }
}

void WifiConnect1(lv_event_t * e)
{
    // 连接到第一个wifi
    extern lv_obj_t * uic_Wifilistlabel1;
    if (uic_Wifilistlabel1) {
        const char *ssid = lv_label_get_text(uic_Wifilistlabel1);
        ui_set_pwd_screen_ssid(ssid);
        nvs_handle_t nvs_handle;
        if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
            nvs_set_str(nvs_handle, "wifi_ssid", ssid);
            nvs_commit(nvs_handle);
            nvs_close(nvs_handle);
        }
    }
}
void WifiConnect2(lv_event_t * e)
{
    extern lv_obj_t * ui_Wifilistlabel2;
    if (ui_Wifilistlabel2) {
        const char *ssid = lv_label_get_text(ui_Wifilistlabel2);
        ui_set_pwd_screen_ssid(ssid);
        nvs_handle_t nvs_handle;
        if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
            nvs_set_str(nvs_handle, "wifi_ssid", ssid);
            nvs_commit(nvs_handle);
            nvs_close(nvs_handle);
        }
    }
}
void WifiConnect3(lv_event_t * e)
{
    extern lv_obj_t * ui_Wifilistlabel3;
    if (ui_Wifilistlabel3) {
        const char *ssid = lv_label_get_text(ui_Wifilistlabel3);
        ui_set_pwd_screen_ssid(ssid);
        nvs_handle_t nvs_handle;
        if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
            nvs_set_str(nvs_handle, "wifi_ssid", ssid);
            nvs_commit(nvs_handle);
            nvs_close(nvs_handle);
        }
    }
}
void WifiConnect4(lv_event_t * e)
{
    extern lv_obj_t * ui_Wifilistlabel4;
    if (ui_Wifilistlabel4) {
        const char *ssid = lv_label_get_text(ui_Wifilistlabel4);
        ui_set_pwd_screen_ssid(ssid);
        nvs_handle_t nvs_handle;
        if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
            nvs_set_str(nvs_handle, "wifi_ssid", ssid);
            nvs_commit(nvs_handle);
            nvs_close(nvs_handle);
        }
    }
}
void WifiConnect5(lv_event_t * e)
{
    extern lv_obj_t * ui_Wifilistlabel5;
    if (ui_Wifilistlabel5) {
        const char *ssid = lv_label_get_text(ui_Wifilistlabel5);
        ui_set_pwd_screen_ssid(ssid);
        nvs_handle_t nvs_handle;
        if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
            nvs_set_str(nvs_handle, "wifi_ssid", ssid);
            nvs_commit(nvs_handle);
            nvs_close(nvs_handle);
        }
    }
}
void WifiConnect6(lv_event_t * e)
{
    extern lv_obj_t * ui_Wifilistlabel6;
    if (ui_Wifilistlabel6) {
        const char *ssid = lv_label_get_text(ui_Wifilistlabel6);
        ui_set_pwd_screen_ssid(ssid);
        nvs_handle_t nvs_handle;
        if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
            nvs_set_str(nvs_handle, "wifi_ssid", ssid);
            nvs_commit(nvs_handle);
            nvs_close(nvs_handle);
        }
    }
}
void WifiConnect7(lv_event_t * e)
{
    extern lv_obj_t * ui_Wifilistlabel7;
    if (ui_Wifilistlabel7) {
        const char *ssid = lv_label_get_text(ui_Wifilistlabel7);
        ui_set_pwd_screen_ssid(ssid);
        nvs_handle_t nvs_handle;
        if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
            nvs_set_str(nvs_handle, "wifi_ssid", ssid);
            nvs_commit(nvs_handle);
            nvs_close(nvs_handle);
        }
    }
}
void WifiConnect8(lv_event_t * e)
{
    extern lv_obj_t * ui_Wifilistlabel8;
    if (ui_Wifilistlabel8) {
        const char *ssid = lv_label_get_text(ui_Wifilistlabel8);
        ui_set_pwd_screen_ssid(ssid);
        nvs_handle_t nvs_handle;
        if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
            nvs_set_str(nvs_handle, "wifi_ssid", ssid);
            nvs_commit(nvs_handle);
            nvs_close(nvs_handle);
        }
    }
}
void WifiConnect9(lv_event_t * e)
{
    extern lv_obj_t * ui_Wifilistlabel9;
    if (ui_Wifilistlabel9) {
        const char *ssid = lv_label_get_text(ui_Wifilistlabel9);
        ui_set_pwd_screen_ssid(ssid);
        nvs_handle_t nvs_handle;
        if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
            nvs_set_str(nvs_handle, "wifi_ssid", ssid);
            nvs_commit(nvs_handle);
            nvs_close(nvs_handle);
        }
    }
}

void ConnectWifi(lv_event_t * e)
{
    // 读取SSID和密码
    extern lv_obj_t * ui_SSIDlabel;
    extern lv_obj_t * ui_wifipwdarea;
    const char *ssid = lv_label_get_text(ui_SSIDlabel);
    const char *pwd = lv_textarea_get_text(ui_wifipwdarea);
    // 保存到nvs
    nvs_handle_t nvs_handle;
    if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
        nvs_set_str(nvs_handle, "wifi_ssid", ssid);
        nvs_set_str(nvs_handle, "wifi_pwd", pwd);
        nvs_commit(nvs_handle);
        nvs_close(nvs_handle);
    }
    // 初始化WiFi（如未初始化）
    wifi_mode_t mode;
    if (esp_wifi_get_mode(&mode) == ESP_OK) {
        s_wifi_inited = true;
    }
    if (!s_wifi_inited) {
        wifi_init_config_t wifi_init_cfg = WIFI_INIT_CONFIG_DEFAULT();
        esp_err_t ret = esp_wifi_init(&wifi_init_cfg);
        if (ret != ESP_OK) return;
        ret = esp_wifi_set_mode(WIFI_MODE_STA);
        if (ret != ESP_OK) return;
        s_wifi_inited = true;
    }
    if (!s_wifi_started) {
        if (esp_wifi_start() == ESP_OK) s_wifi_started = true;
    }
    // 配置并连接
    wifi_config_t wifi_config = {0};
    size_t ssid_len = strlen(ssid);
    if (ssid_len > sizeof(wifi_config.sta.ssid)) ssid_len = sizeof(wifi_config.sta.ssid);
    memcpy(wifi_config.sta.ssid, ssid, ssid_len);
    size_t pwd_len = strlen(pwd);
    if (pwd_len > sizeof(wifi_config.sta.password)) pwd_len = sizeof(wifi_config.sta.password);
    memcpy(wifi_config.sta.password, pwd, pwd_len);
    wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;
    wifi_config.sta.pmf_cfg.capable = true;
    wifi_config.sta.pmf_cfg.required = false;
    esp_wifi_set_config(WIFI_IF_STA, &wifi_config);
    esp_wifi_connect();
}

void BT_on(lv_event_t * e)
{
	// Your code here
}

void BT_check(lv_event_t * e)
{
	// 检查蓝牙状态 如果蓝牙已经打开 则将uic_BTButton和uic_BTSwitch设置为checked 如果未连接到蓝牙则将uic_BTStatusLabel内容设置为disconnected uic_BTSsidLabel内容设置为Bluetooth 如果已连接上则将uic_BTStatusLabel内容设置为connected 同时uic_BTSsidLabel内容设置为当前连接的蓝牙设备名称

}

void BT_scan(lv_event_t * e)
{
	// 扫描附近的蓝牙设备
    //将扫描结果显示在uic_BTlist1-9中的BTlistlabel1-9中
    //如果扫描到的设备超过9个，则只显示前9个
    //如果没有扫描到设备或者少于9，则将多余的uic_BTlist设置为隐藏
    //如果有已连接的设备，uic_CurrentBT下的CurrentBTLabel显示已连接的设备名称 否则隐藏uic_CurrentBT

}

void BT_off(lv_event_t * e)
{
	// 关闭蓝牙
    //将uic_BTButton和uic_BTSwitch设置为未选中状态
    //将uic_BTStatusLabel内容设置为disconnected
    //将uic_BTSsidLabel内容设置为Bluetooth
    //隐藏uic_BTlist
}

void BT_Connect1(lv_event_t * e)
{
	// 连接蓝牙设备1
}

void BT_Connect2(lv_event_t * e)
{
	// 连接蓝牙设备2
}

void BT_Connect3(lv_event_t * e)
{
	//  连接蓝牙设备3
}

void BT_Connect4(lv_event_t * e)
{
	// 连接蓝牙设备4
}

void BT_Connect5(lv_event_t * e)
{
	//  连接蓝牙设备5
}

void BT_Connect6(lv_event_t * e)
{
	//  连接蓝牙设备6
}

void BT_Connect7(lv_event_t * e)
{
	//  连接蓝牙设备7
}

void BT_Connect8(lv_event_t * e)
{
	//  连接蓝牙设备8
}

void BT_Connect9(lv_event_t * e)
{
	//  连接蓝牙设备9
}

void LoadMedia(lv_event_t * e)
{
	// Your code here
}

void LastMusic(lv_event_t * e)
{
	// 上一首
}

void PauseResume(lv_event_t * e)
{
	// 暂停/继续
}

void NextMusic(lv_event_t * e)
{
	// 下一首
}

void AboutInfo(lv_event_t * e)
{
    (void)e;
    // 显示本机 MAC（稳健获取，避免全 0 / 类型不匹配）
    uint8_t mac[6] = {0};
    if (get_sta_mac(mac) == ESP_OK) {
        char buf[32];
        snprintf(buf, sizeof(buf), "%02X:%02X:%02X:%02X:%02X:%02X",
                 mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
        if (uic_MACLabel) lv_label_set_text(uic_MACLabel, buf);
    } else {
        if (uic_MACLabel) lv_label_set_text(uic_MACLabel, "N/A");
    }

    // 从 NVS 读取电脑 IP
    char ip[16] = {0};
    nvs_handle_t h;
    if (nvs_open("storage", NVS_READONLY, &h) == ESP_OK) {
        size_t len = sizeof(ip);
        if (nvs_get_str(h, "computer_ip", ip, &len) != ESP_OK) ip[0] = 0;
        nvs_close(h);
    }
    if (ip[0]) {
        if (uic_ComputerIParea) lv_textarea_set_text(uic_ComputerIParea, ip);
        if (uic_ComputerIPLabel) lv_label_set_text(uic_ComputerIPLabel, ip);
        if (uic_IPLabel) lv_label_set_text(uic_IPLabel, ip);
    }
}

void SetComputerIP(lv_event_t * e)
{
    (void)e;
    if (!uic_ComputerIParea) return;
    const char *txt = lv_textarea_get_text(uic_ComputerIParea);
    if (!txt || !txt[0]) return;

    int a,b,c,d;
    if (sscanf(txt, "%d.%d.%d.%d", &a,&b,&c,&d) != 4 ||
        a<0||a>255||b<0||b>255||c<0||c>255||d<0||d>255) {
        // 简单无效输入处理：清空
        // (可扩展为提示窗口)
        return;
    }
    nvs_handle_t h;
    if (nvs_open("storage", NVS_READWRITE, &h) == ESP_OK) {
        nvs_set_str(h, "computer_ip", txt);
        nvs_commit(h);
        nvs_close(h);
    }
    if (uic_ComputerIPLabel) lv_label_set_text(uic_ComputerIPLabel, txt);
    if (uic_IPLabel) lv_label_set_text(uic_IPLabel, txt);
}

void ConnectComputer(lv_event_t * e)
{
    (void)e;
    // 从 NVS 读取 IP
    char ip[16] = {0};
    nvs_handle_t h;
    if (nvs_open("storage", NVS_READONLY, &h) == ESP_OK) {
        size_t len = sizeof(ip);
        if (nvs_get_str(h, "computer_ip", ip, &len) != ESP_OK) ip[0] = 0;
        nvs_close(h);
    }
    if (!ip[0]) return;
    // 显示加载动画
    if (uic_loading) lv_obj_clear_flag(uic_loading, LV_OBJ_FLAG_HIDDEN);
    tasks_start_pc_monitor(ip);
}

void DisconnectComputer(lv_event_t * e)
{
    (void)e;
    tasks_stop_pc_monitor();
    if (uic_loading) lv_obj_clear_flag(uic_loading, LV_OBJ_FLAG_HIDDEN);
    // 可选：清空显示（保持原样也可）
    if (bsp_display_lock(50)) {
        if (uic_CPULoadLabel) lv_label_set_text(uic_CPULoadLabel, "--");
        if (uic_GPULoadLabel) lv_label_set_text(uic_GPULoadLabel, "--");
        if (uic_RAMLoadLabel) lv_label_set_text(uic_RAMLoadLabel, "RAM:--");
        if (uic_UploadLabel) lv_label_set_text(uic_UploadLabel, "Upload:--");
        if (uic_DownloadLabel) lv_label_set_text(uic_DownloadLabel, "Download:--");
        if (uic_CPULoad) lv_arc_set_value(uic_CPULoad, 0);
        if (uic_GPULoad) lv_arc_set_value(uic_GPULoad, 0);
        if (uic_RAMLoad) lv_bar_set_value(uic_RAMLoad, 0, LV_ANIM_OFF);
        if (uic_Disk1Label) lv_obj_add_flag(uic_Disk1Label, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk2Label) lv_obj_add_flag(uic_Disk2Label, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk3Label) lv_obj_add_flag(uic_Disk3Label, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk4Label) lv_obj_add_flag(uic_Disk4Label, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk5Label) lv_obj_add_flag(uic_Disk5Label, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk6Label) lv_obj_add_flag(uic_Disk6Label, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk1Load) lv_obj_add_flag(uic_Disk1Load, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk2Load) lv_obj_add_flag(uic_Disk2Load, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk3Load) lv_obj_add_flag(uic_Disk3Load, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk4Load) lv_obj_add_flag(uic_Disk4Load, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk5Load) lv_obj_add_flag(uic_Disk5Load, LV_OBJ_FLAG_HIDDEN);
        if (uic_Disk6Load) lv_obj_add_flag(uic_Disk6Load, LV_OBJ_FLAG_HIDDEN);

        bsp_display_unlock();
    }
}
void Startfileserver(lv_event_t * e)
{
	// Your code here
}

void Stopfileserver(lv_event_t * e)
{
	// Your code here
}

void StartAutoBrightness(lv_event_t * e)
{
	// 开启自动亮度：保存开关并启动定时器
    (void)e;
    nvs_handle_t h;
    if (nvs_open("storage", NVS_READWRITE, &h) == ESP_OK) {
        nvs_set_i32(h, "auto_brightness", 1);
        nvs_commit(h);
        nvs_close(h);
    }
    auto_brightness_start();
}

void StopAutoBrightness(lv_event_t * e)
{
	// 关闭自动亮度：保存开关并停止定时器，恢复到基准亮度
    (void)e;
    nvs_handle_t h;
    if (nvs_open("storage", NVS_READWRITE, &h) == ESP_OK) {
        nvs_set_i32(h, "auto_brightness", 0);
        nvs_commit(h);
        nvs_close(h);
    }
    auto_brightness_stop();
}

void LoadWeather(lv_event_t * e)
{
	// 进入天气页面时，触发一次后台“立即刷新”
    (void)e;
    tasks_request_weather_now();
}

void ChangeVolume(lv_event_t * e)
{
	// 获取滑块对象和当前值
    lv_obj_t * slider = lv_event_get_target(e);
    int32_t value = lv_slider_get_value(slider);

    // 设置音量
    //TODO: Implement the function to set the volume

    // 保存音量到NVS
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err == ESP_OK) {
        nvs_set_i32(nvs_handle, "volume", value);
        nvs_commit(nvs_handle);
        nvs_close(nvs_handle);
    }
}

// 新增：MAC 工具函数
static bool mac_is_zero(const uint8_t mac[6]) {
    for (int i = 0; i < 6; ++i) if (mac[i]) return false;
    return true;
}

static esp_err_t get_sta_mac(uint8_t mac[6]) {
    if (!mac) return ESP_ERR_INVALID_ARG;
    memset(mac, 0, 6);

    // 1) 优先从 Wi-Fi 驱动获取（若已初始化/启动）
    esp_err_t err = esp_wifi_get_mac(WIFI_IF_STA, mac);
    if (err == ESP_OK && !mac_is_zero(mac)) return ESP_OK;

    // 2) 获取应用层设置的基址 MAC
    err = esp_base_mac_addr_get(mac);
    if (err == ESP_OK && !mac_is_zero(mac)) return ESP_OK;

    // 3) 从 eFuse 读取出厂 MAC
    err = esp_efuse_mac_get_default(mac);
    if (err == ESP_OK && !mac_is_zero(mac)) return ESP_OK;

    return ESP_FAIL;
}